// Generated by CoffeeScript 1.4.0
(function() {
  var Stream, delay, geekdaq, inspect, isString, log, pretty, randInt,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inspect = require('util').inspect;

  Stream = require('stream');

  geekdaq = require('geekdaq');

  delay = function(t, f) {
    return setTimeout(f, t);
  };

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  randInt = function(min, max) {
    return Math.round(min + Math.random() * (max - min));
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  log = console.log;

  module.exports = (function(_super) {

    __extends(exports, _super);

    function exports(options) {
      var account, accounts, code, k, v, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (options == null) {
        options = {};
      }
      this.execute = __bind(this.execute, this);

      this.transfert = __bind(this.transfert, this);

      this.register = __bind(this.register, this);

      this.ticker = __bind(this.ticker, this);

      this.start = __bind(this.start, this);

      this.stop = __bind(this.stop, this);

      this.update = __bind(this.update, this);

      this.server = (_ref = options.server) != null ? _ref : 'geekdaq';
      this.codes = (_ref1 = options.tickers) != null ? _ref1 : [];
      this.updateInterval = (_ref2 = options.updateInterval) != null ? _ref2 : 500;
      this.commissions = (_ref3 = options.commissions) != null ? _ref3 : {
        buy: 0,
        sell: 0
      };
      accounts = (_ref4 = options.accounts) != null ? _ref4 : [];
      this.accounts = {};
      if (Array.isArray(accounts)) {
        for (_i = 0, _len = accounts.length; _i < _len; _i++) {
          account = accounts[_i];
          this.accounts[account.username] = account;
        }
      } else {
        for (k in accounts) {
          v = accounts[k];
          this.accounts[k] = v;
        }
      }
      this.tickers = {};
      _ref5 = this.codes;
      for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
        code = _ref5[_j];
        this.tickers[code] = {
          func: geekdaq.generator({
            range: 5,
            levels: 150
          }),
          price: randInt(100, 400),
          volume: randInt(100000, 400000)
        };
      }
      this.running = false;
    }

    exports.prototype.update = function() {
      var code, ticker, _ref,
        _this = this;
      if (this.running) {
        _ref = this.tickers;
        for (code in _ref) {
          ticker = _ref[code];
          ticker.price += ticker.func();
        }
        return delay(this.updateInterval, function() {
          return _this.update();
        });
      } else {
        return this.emit('stopped');
      }
    };

    exports.prototype.stop = function() {
      this.emit('stopping');
      if (this.running) {
        this.running = false;
        return;
      }
      return this.emit('stopped');
    };

    exports.prototype.start = function() {
      this.emit('starting');
      if (this.running) {
        this.emit('started');
        return;
      }
      this.running = true;
      this.emit('started');
      return this.update();
    };

    exports.prototype.ticker = function(t) {
      if (isString(t)) {
        return this.tickers[t];
      } else {
        return t;
      }
    };

    exports.prototype.register = function(account) {
      this.accounts[account.username] = account;
      return this.emit('registration', account.username);
    };

    exports.prototype.transfert = function(username, amount, origin) {
      this.accounts[username].balance += amount;
      if (origin != null) {
        this.accounts[origin].balance -= amount;
        return this.emit('transfert', username, amount, origin);
      } else {
        return this.emit('transfert', username, amount);
      }
    };

    exports.prototype.execute = function(_arg) {
      var account, amount, msg, onComplete, order, orders, raw_cost, raw_earnings, ticker, total_cost, total_earnings, username, _i, _len;
      username = _arg.username, orders = _arg.orders, onComplete = _arg.onComplete;
      account = this.accounts[username];
      this.emit('debug', "username: " + username + " and account: " + (pretty(account)));
      for (_i = 0, _len = orders.length; _i < _len; _i++) {
        order = orders[_i];
        this.emit('debug', "going to " + order.type + " " + order.amount + " " + order.ticker + ":");
        ticker = this.ticker(order.ticker);
        switch (order.type) {
          case 'buy':
            raw_cost = order.amount * ticker.price;
            total_cost = raw_cost + (raw_cost * this.commissions.buy);
            this.emit('debug', "buy total cost: " + total_cost);
            if (account.balance < total_cost) {
              msg = "" + username + "'s balance is " + account.balance + ", but cost is " + total_cost;
              this.emit('error', 'NOT_ENOUGH_MONEY', msg);
            } else {
              account.balance -= total_cost;
              if (order.symbol in account.portfolio) {
                account.portfolio[order.ticker] += order.amount;
              } else {
                account.portfolio[order.ticker] = order.amount;
              }
              account.history.push({
                type: order.type,
                ticker: order.ticker,
                amount: order.amount,
                price: ticker.price,
                expenses: total_cost
              });
            }
            break;
          case 'sell':
            if (!(order.ticker in account.portfolio)) {
              msg = "" + username + " doesn't own any " + order.ticker;
              this.emit('error', 'NOT_IN_PORTFOLIO', msg);
            } else {
              amount = account.portfolio[order.ticker];
              if (amount < order.amount) {
                msg = "" + username + " doesn't have enough " + order.ticker + " to sell (want to sell " + order.amount + ", but we have " + amount + ")";
                this.emit('error', 'NOT_ENOUGH_SHARES', msg);
              } else {
                raw_earnings = amount * ticker.price;
                total_earnings = raw_earnings - (raw_earnings * this.commissions.sell);
                this.emit('debug', "total earnings: " + total_earnings);
                account.portfolio[order.ticker] -= order.amount;
                account.balance += total_earnings;
                account.history.push({
                  type: order.type,
                  ticker: order.ticker,
                  amount: order.amount,
                  price: ticker.price,
                  earnings: total_earnings
                });
              }
            }
            break;
          default:
            msg = "unknown order type '" + order.type + "'";
            this.emit('error', 'UNKNOWN_ORDER_TYPE', msg);
        }
      }
      return onComplete(void 0);
    };

    return exports;

  })(Stream);

}).call(this);
