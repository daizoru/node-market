// Generated by CoffeeScript 1.4.0
(function() {
  var delay, geekdaq, inspect, randInt,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  delay = require('ragtime').delay;

  geekdaq = require('geekdaq');

  randInt = function(min, max) {
    return Math.round(min + Math.random() * (max - min));
  };

  module.exports = (function() {

    function exports(options) {
      var code, errors, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (options == null) {
        options = {};
      }
      this.execute = __bind(this.execute, this);

      this.penalty = __bind(this.penalty, this);

      this.register = __bind(this.register, this);

      this.ticker = __bind(this.ticker, this);

      this.start = __bind(this.start, this);

      this.stop = __bind(this.stop, this);

      this.update = __bind(this.update, this);

      this.server = (_ref = options.server) != null ? _ref : 'geekdaq';
      this.codes = (_ref1 = options.tickers) != null ? _ref1 : [];
      this.updateInterval = (_ref2 = options.updateInterval) != null ? _ref2 : 500;
      this.commissions = (_ref3 = options.commissions) != null ? _ref3 : {
        buy: 0,
        sell: 0
      };
      errors = {
        trivial: function(x) {
          return x;
        },
        minor: function(x) {
          return x;
        },
        major: function(x) {
          return x;
        }
      };
      this.errors = (_ref4 = options.errors) != null ? _ref4 : errors;
      this.tickers = {};
      _ref5 = this._codes;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        code = _ref5[_i];
        this.tickers[code] = {
          func: geekdaq.generator({
            range: 5,
            levels: 150
          }),
          price: randInt(100, 400),
          volume: randInt(100000, 400000)
        };
      }
      this.running = false;
    }

    exports.prototype.update = function() {
      var code, ticker, _ref,
        _this = this;
      if (this.running) {
        _ref = this.tickers;
        for (code in _ref) {
          ticker = _ref[code];
          ticker.price += ticker.func();
        }
        return delay(updateInterval, function() {
          return _this.update();
        });
      }
    };

    exports.prototype.stop = function() {
      return this.running = false;
    };

    exports.prototype.start = function() {
      if (this.running) {
        return;
      }
      this.running = true;
      return this.update();
    };

    exports.prototype.ticker = function(code) {
      return this.tickers[code];
    };

    exports.prototype.register = function(account) {
      return this.accounts[account.username] = account;
    };

    exports.prototype.penalty = function(username, amount) {
      return this.accounts[account.username].balance -= amount;
    };

    exports.prototype.execute = function(_arg) {
      var account, amount, major, minor, order, orders, raw_benefits, raw_cost, ticker, total_benefits, total_cost, trivial, username, _i, _len, _ref;
      username = _arg.username, orders = _arg.orders;
      _ref = this.errors, trivial = _ref.trivial, minor = _ref.minor, major = _ref.major;
      account = this.accounts[username];
      for (_i = 0, _len = orders.length; _i < _len; _i++) {
        order = orders[_i];
        info("processing " + order.type + " order:");
        ticker = this.ticker(order.ticker);
        switch (order.type) {
          case 'buy':
            raw_cost = order.amount * ticker.price;
            total_cost = raw_cost + (raw_cost * this.commissions.buy);
            debug("total cost: " + total_cost);
            if (account.balance < total_cost) {
              alert(trivial("cannot execute order: not enough money"));
            } else {
              account.balance -= total_cost;
              if (order.symbol in account.portfolio) {
                account.portfolio[order.ticker] += order.amount;
              } else {
                account.portfolio[order.ticker] = order.amount;
              }
              account.history.push({
                type: order.type,
                ticker: order.ticker,
                amount: order.amount,
                price: ticker.price,
                total_cost: total_cost
              });
            }
            break;
          case 'sell':
            if (!(order.ticker in account.portfolio)) {
              alert(minor("invalid order: we do not own any " + order.ticker));
              return;
            }
            amount = account.portfolio[order.ticker];
            if (amount < order.amount) {
              alert(minor("invalid order: we do not have enough " + order.ticker + " shares (want to sell " + order.amount + ", but we have " + amount + ")"));
              return;
            }
            raw_benefits = amount * ticker.price;
            total_benefits = raw_benefits - (raw_benefits * this.commissions.sell);
            debug("total benefits: " + total_benefits);
            account.portfolio[order.ticker] -= order.amount;
            account.balance += total_benefits;
            account.history.push({
              type: order.type,
              ticker: order.symbol,
              amount: order.amount,
              price: ticker.price,
              total_benefit: total_benefits
            });
        }
      }
    };

    return exports;

  })();

}).call(this);
