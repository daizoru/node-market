// Generated by CoffeeScript 1.4.0
(function() {
  var Bond, Market, P, Product, Security, Session, Stock, UNIT, crypto, delay, humanize, inspect, log, randfloat, randint, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  log = console.log;

  crypto = require('crypto');

  _ref = require('daizoru-toolbox'), delay = _ref.delay, P = _ref.P, randint = _ref.randint, randfloat = _ref.randfloat;

  UNIT = 1000;

  humanize = function(value) {
    return "$" + (Math.round(value) / UNIT);
  };

  Session = (function() {
    /*
      A simple user session. managed by the server
    */

    function Session(market, passphrase, username, hashedPassword) {
      this.market = market;
      this.passphrase = passphrase;
      this.username = username;
      this.hashedPassword = hashedPassword;
    }

    Session.prototype.buy = function(symbol, volume, onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.buy(query, symbol, volume);
    };

    Session.prototype.sell = function(symbol, volume, onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.sell(query, symbol, volume);
    };

    Session.prototype.balance = function(onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.balance(query);
    };

    Session.prototype.quote = function(symbol, onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.quote(query, symbol);
    };

    Session.prototype.logout = function(onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.logout(query);
    };

    return Session;

  })();

  Product = (function() {

    function Product(args) {
      if (args == null) {
        args = {};
      }
      this.name = args.name != null ? args.name : "";
      this.symbol = args.symbol != null ? args.symbol.toUpperCase() : this.name.toUpperCase();
      this.volume = args.volume != null ? args.volume : 0;
      this.price = args.price != null ? args.price * UNIT : 1;
      this.market = false;
    }

    return Product;

  })();

  Security = (function() {

    function Security(args) {
      if (args == null) {
        args = {};
      }
      this.market = false;
      this.name = args.name != null ? args.name : "";
      this.symbol = args.symbol != null ? args.symbol.toUpperCase() : this.name.toUpperCase();
      this.volume = args.volume != null ? args.volume : 0;
      this.price = args.price != null ? args.price * UNIT : 1;
    }

    return Security;

  })();

  Stock = (function(_super) {

    __extends(Stock, _super);

    function Stock(args) {
      if (args == null) {
        args = {};
      }
      Stock.__super__.constructor.call(this, args);
    }

    return Stock;

  })(Security);

  Bond = (function(_super) {

    __extends(Bond, _super);

    function Bond(args) {
      if (args == null) {
        args = {};
      }
      Bond.__super__.constructor.call(this, args);
      this.holder = "";
      this.issuer = "";
      /* Coupon
      
       the interest rate that the issuer pays to the bond holders.
      
       Usually this rate is fixed throughout the life of the bond.
       It can also vary with a money market index, such as LIBOR,
       or it can be even more exotic. The name coupon originates
       from the fact that in the past, physical bonds were issued
       which had coupons attached to them. On coupon dates the
       bond holder would give the coupon to a bank in exchange
       for the interest payment. Coupons can be paid at different
       frequencies. It is generally semi-annual or annual.
      */

      this.coupon = 0;
      /* Maturity
      
      the date on which the issuer has to repay the nominal amount. 
      
      As long as all payments have been made, the issuer has no more 
      obligation to the bond holders after the maturity date. The 
      length of time until the maturity date is often referred to as
      the term or tenor or maturity of a bond. The maturity can be
      any length of time, although debt securities with a term of
      less than one year are generally designated money market
      instruments rather than bonds. Most bonds have a term of up to
      thirty years. Some bonds have been issued with maturities of
      up to one hundred years, and some do not mature at all. In the
      market for U.S. Treasury securities, there are three groups of
      bond maturities:
        - short term (bills): maturities between one to five year; 
          (instruments with maturities less than one year are called
          Money Market Instruments)
        - medium term (notes): maturities between six to twelve years;
        - long term (bonds): maturities greater than twelve years.
      
      source: Wikipedia
      link: http://en.wikipedia.org/wiki/Bond_(finance)
      */

      this.maturity = 0;
      this.quality = false;
      this.optionality = false;
    }

    return Bond;

  })(Security);

  Market = (function() {

    function Market(args) {
      var account, login, product, symbol, _ref1, _ref2,
        _this = this;
      if (args == null) {
        args = {};
      }
      this.login = __bind(this.login, this);

      this.updateQuotes = __bind(this.updateQuotes, this);

      this.name = args.name != null ? args.name : "Market";
      this.symbol = args.symbol != null ? args.symbol : "MARK";
      this.products = {};
      if (args.products) {
        _ref1 = args.products;
        for (symbol in _ref1) {
          product = _ref1[symbol];
          product.market = this;
          this.products[symbol] = product;
        }
      }
      this.accounts = {};
      if (args.products) {
        _ref2 = args.accounts;
        for (login in _ref2) {
          account = _ref2[login];
          this.createAccount(login, account.password, account.balance);
        }
      }
      this.sessions = {};
      this.runMarket = false;
      this.model = {
        cycles: 0,
        tendency: 0.5
      };
      this.model.priceVariation = function() {
        var res;
        if (_this.model.cycles++ >= 10) {
          _this.model.cycles = 0;
          _this.model.tendency = 0.5 - Math.random();
        }
        res = Math.random() * 200;
        res *= _this.model.tendency;
        return res;
      };
    }

    Market.prototype.hash = function(txt) {
      return crypto.createHmac('sha1', "randomsalt").update(txt).digest('hex');
    };

    Market.prototype.open = function() {
      this.runMarket = true;
      return this.updateQuotes();
    };

    Market.prototype.close = function() {
      return this.runMarket = false;
    };

    Market.prototype.createAccount = function(username, password, balance) {
      if (balance == null) {
        balance = eur(0);
      }
      username = username.toLowerCase();
      log("creating account " + username + ", password " + password + ", balance " + balance);
      if (username in this.accounts) {
        throw "user " + username + " already exists";
        return;
      }
      return this.accounts[username] = {
        username: username,
        password: this.hash(password),
        balance: balance.multiply(UNIT),
        stocks: {}
      };
    };

    Market.prototype.logout = function(query) {
      var account;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      delete this.sessions[query.Session];
      return query.reply();
    };

    Market.prototype.validate = function(query) {
      var account, session;
      query.refuse = function(err) {
        if (err == null) {
          err = '';
        }
        delay(0, function() {
          return query.cb(err, 0);
        });
      };
      query.reply = function(value) {
        if (value == null) {
          value = '';
        }
        delay(0, function() {
          return query.cb('', value);
        });
      };
      session = this.sessions[query.session];
      if (session) {
        account = this.accounts[session.username];
        return account;
      } else {
        return false;
      }
    };

    Market.prototype.updateQuotes = function() {
      var old, symbol, volume, _ref1,
        _this = this;
      if (!this.runMarket) {
        return;
      }
      _ref1 = this.products;
      for (symbol in _ref1) {
        volume = _ref1[symbol];
        old = this.products[symbol].price;
        this.products[symbol].price += this.model.priceVariation();
      }
      return delay(1000, function() {
        return _this.updateQuotes();
      });
    };

    Market.prototype.login = function(username, password, onComplete) {
      var account, hashedPassword, query, session, sessionPassphrase;
      username = username.toLowerCase();
      if (!(username in this.accounts)) {
        throw "Unknow user \"" + username + "\"";
        return;
      }
      account = this.accounts[username];
      hashedPassword = this.hash(password);
      if (hashedPassword !== account.password) {
        throw "Error, invalid password. Hacking is a crime. Try again and you will face prosecution";
        return;
      }
      sessionPassphrase = "" + username + ":" + hashedPassword + ":salt";
      session = new Session(this, sessionPassphrase, username, hashedPassword);
      this.sessions[sessionPassphrase] = session;
      query = {
        session: session,
        cb: onComplete
      };
      account = this.validate(query);
      return query.reply(query.session);
    };

    Market.prototype.quote = function(query, symbol) {
      var account, stock;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      stock = this.products[symbol];
      if (!stock) {
        return query.refuse("unknow symbol " + symbol);
      }
      return query.reply(stock.price);
    };

    Market.prototype.buy = function(query, symbol, volume) {
      var account, averagePrice, commission, cost, existingPrice, futurePrice, stock;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      symbol = symbol.toUpperCase();
      if (symbol in this.products) {
        stock = this.products[symbol];
        if (volume <= stock.volume) {
          existingPrice = stock.price;
          futurePrice = existingPrice + existingPrice * (volume / stock.volume);
          averagePrice = (existingPrice + futurePrice) / 2;
          cost = averagePrice * volume;
          commission = this.commission(cost);
          cost += commission;
          if (account.balance >= cost) {
            account.balance -= cost;
            this.products[symbol].price = futurePrice;
            if (!(symbol in account.stocks)) {
              account.stocks[symbol] = {
                volume: 0
              };
            }
            account.stocks[symbol].volume += volume;
            this.products[symbol].volume -= volume;
            return query.reply();
          } else {
            return query.refuse("for some reason");
          }
        } else {
          return query.refuse("you don't have enough shares to sell");
        }
      } else {
        return query.refuse("symbol " + symbol + " not found");
      }
    };

    Market.prototype.sell = function(query, symbol, volume) {
      var account, averagePrice, commission, earnings, existingPrice, futurePrice, stock;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      symbol = symbol.toUpperCase();
      if (symbol in this.products) {
        stock = this.products[symbol];
        if (!(symbol in account.stocks)) {
          return query.refuse("user don't own any share of " + symbol);
        }
        if (volume <= account.stocks[symbol].volume) {
          existingPrice = stock.price;
          futurePrice = existingPrice - existingPrice * (volume / stock.volume);
          averagePrice = (existingPrice + futurePrice) / 2;
          earnings = averagePrice * volume;
          commission = this.commission(earnings);
          earnings -= commission;
          if (true) {
            account.balance += earnings;
            this.products[symbol].price = futurePrice;
            account.stocks[symbol].volume -= volume;
            this.products[symbol].volume += volume;
            return query.reply();
          } else {
            return query.refuse("for some reason");
          }
        } else {
          return query.refuse("no more stocks on the market to buy, please wait");
        }
      } else {
        return query.refuse("symbol " + symbol + " not found");
      }
    };

    Market.prototype.balance = function(query) {
      var account;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      return query.reply(account.balance);
    };

    Market.prototype.commission = function(order) {
      var category, estimated;
      category = "A";
      switch (category) {
        case "A":
          if (order <= 500000) {
            return 1990;
          } else {
            return order * 0.006;
          }
          break;
        case "B":
          if (order <= 1000000) {
            return 5500;
          } else {
            estimated = order * 0.0048;
            if (estimated < 8950) {
              estimated = 8950;
            }
            return estimated;
          }
          break;
        case "C":
          if (order <= 7750000) {
            return 16650;
          } else {
            return order * 0.0022;
          }
          break;
        case "D":
          if (order <= 10000000) {
            return 9900;
          } else {
            return order * 0.0012;
          }
          break;
        default:
          return 0;
      }
    };

    return Market;

  })();

  exports.Market = Market;

  exports.Session = Session;

  exports.Stock = Stock;

  exports.humanize = humanize;

  exports.Product = Product;

}).call(this);
