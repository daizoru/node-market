// Generated by CoffeeScript 1.3.3
(function() {
  var Market, P, Session, Stock, UNIT, crypto, delay, humanize, inspect, log, randfloat, randint, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  log = console.log;

  crypto = require('crypto');

  _ref = require('daizoru-toolbox'), delay = _ref.delay, P = _ref.P, randint = _ref.randint, randfloat = _ref.randfloat;

  UNIT = 1000;

  humanize = function(value) {
    return "$" + (Math.round(value) / UNIT);
  };

  Session = (function() {
    /*
      A simple user session. managed by the server
    */

    function Session(market, passphrase, username, hashedPassword) {
      this.market = market;
      this.passphrase = passphrase;
      this.username = username;
      this.hashedPassword = hashedPassword;
    }

    Session.prototype.buy = function(symbol, volume, onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.buy(query, symbol, volume);
    };

    Session.prototype.sell = function(symbol, volume, onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.sell(query, symbol, volume);
    };

    Session.prototype.balance = function(onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.balance(query);
    };

    Session.prototype.quote = function(symbol, onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.quote(query, symbol);
    };

    Session.prototype.logout = function(onComplete) {
      var query;
      query = {
        session: this.passphrase,
        cb: onComplete
      };
      return this.market.logout(query);
    };

    return Session;

  })();

  Stock = (function() {

    function Stock(args) {
      if (args == null) {
        args = {};
      }
      this.name = args.name != null ? args.name : "";
      this.symbol = args.symbol != null ? args.symbol.toUpperCase() : this.name.toUpperCase();
      this.volume = args.volume != null ? args.volume : 0;
      this.price = args.price != null ? args.price * UNIT : 1;
      this.market = false;
    }

    return Stock;

  })();

  Market = (function() {

    function Market(args) {
      var product, symbol, _ref1,
        _this = this;
      if (args == null) {
        args = {};
      }
      this.login = __bind(this.login, this);

      this.updateQuotes = __bind(this.updateQuotes, this);

      this.name = args.name != null ? args.name : "Market";
      this.symbol = args.symbol != null ? args.symbol : "MARK";
      this.products = {};
      if (args.products) {
        _ref1 = args.products;
        for (symbol in _ref1) {
          product = _ref1[symbol];
          product.market = this;
          this.products[symbol] = product;
        }
      }
      this.accounts = {};
      this.sessions = {};
      this.runMarket = false;
      this.model = {
        cycles: 0,
        tendency: 0.5
      };
      this.model.priceVariation = function() {
        var res;
        if (_this.model.cycles++ >= 10) {
          _this.model.cycles = 0;
          _this.model.tendency = 0.5 - Math.random();
        }
        res = Math.random() * 200;
        res *= _this.model.tendency;
        return res;
      };
    }

    Market.prototype.hash = function(txt) {
      return crypto.createHmac('sha1', "randomsalt").update(txt).digest('hex');
    };

    Market.prototype.open = function() {
      this.runMarket = true;
      return this.updateQuotes();
    };

    Market.prototype.close = function() {
      return this.runMarket = false;
    };

    Market.prototype.createAccount = function(username, password, balance) {
      if (balance == null) {
        balance = 1;
      }
      username = username.toLowerCase();
      if (username in this.accounts) {
        throw "user " + username + " already exists";
        return;
      }
      return this.accounts[username] = {
        username: username,
        password: this.hash(password),
        balance: balance * UNIT,
        stocks: {}
      };
    };

    Market.prototype.logout = function(query) {
      var account;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      delete this.sessions[query.Session];
      return query.reply();
    };

    Market.prototype.validate = function(query) {
      var account, session;
      query.refuse = function(err) {
        if (err == null) {
          err = '';
        }
        delay(0, function() {
          return query.cb(err, 0);
        });
      };
      query.reply = function(value) {
        if (value == null) {
          value = '';
        }
        delay(0, function() {
          return query.cb('', value);
        });
      };
      session = this.sessions[query.session];
      if (session) {
        account = this.accounts[session.username];
        return account;
      } else {
        return false;
      }
    };

    Market.prototype.updateQuotes = function() {
      var old, symbol, volume, _ref1,
        _this = this;
      if (!this.runMarket) {
        return;
      }
      _ref1 = this.products;
      for (symbol in _ref1) {
        volume = _ref1[symbol];
        old = this.products[symbol].price;
        this.products[symbol].price += this.model.priceVariation();
      }
      return delay(1000, function() {
        return _this.updateQuotes();
      });
    };

    Market.prototype.login = function(username, password, onComplete) {
      var account, hashedPassword, query, session, sessionPassphrase;
      username = username.toLowerCase();
      if (!(username in this.accounts)) {
        throw "Unknow user \"" + username + "\"";
        return;
      }
      account = this.accounts[username];
      hashedPassword = this.hash(password);
      if (hashedPassword !== account.password) {
        throw "Error, invalid password. Hacking is a crime. Try again and you will face prosecution";
        return;
      }
      sessionPassphrase = "" + username + ":" + hashedPassword + ":salt";
      session = new Session(this, sessionPassphrase, username, hashedPassword);
      this.sessions[sessionPassphrase] = session;
      query = {
        session: session,
        cb: onComplete
      };
      account = this.validate(query);
      return query.reply(query.session);
    };

    Market.prototype.quote = function(query, symbol) {
      var account, stock;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      stock = this.products[symbol];
      if (!stock) {
        return query.refuse("unknow symbol " + symbol);
      }
      return query.reply(stock.price);
    };

    Market.prototype.buy = function(query, symbol, volume) {
      var account, averagePrice, commission, cost, existingPrice, futurePrice, stock;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      symbol = symbol.toUpperCase();
      if (symbol in this.products) {
        stock = this.products[symbol];
        if (volume <= stock.volume) {
          existingPrice = stock.price;
          futurePrice = existingPrice + existingPrice * (volume / stock.volume);
          averagePrice = (existingPrice + futurePrice) / 2;
          cost = averagePrice * volume;
          commission = this.commission(cost);
          cost += commission;
          if (account.balance >= cost) {
            account.balance -= cost;
            this.products[symbol].price = futurePrice;
            if (!(symbol in account.stocks)) {
              account.stocks[symbol] = {
                volume: 0
              };
            }
            account.stocks[symbol].volume += volume;
            this.products[symbol].volume -= volume;
            return query.reply();
          } else {
            return query.refuse("for some reason");
          }
        } else {
          return query.refuse("you don't have enough shares to sell");
        }
      } else {
        return query.refuse("symbol " + symbol + " not found");
      }
    };

    Market.prototype.sell = function(query, symbol, volume) {
      var account, averagePrice, commission, earnings, existingPrice, futurePrice, stock;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      symbol = symbol.toUpperCase();
      if (symbol in this.products) {
        stock = this.products[symbol];
        if (!(symbol in account.stocks)) {
          return query.refuse("user don't own any share of " + symbol);
        }
        if (volume <= account.stocks[symbol].volume) {
          existingPrice = stock.price;
          futurePrice = existingPrice - existingPrice * (volume / stock.volume);
          averagePrice = (existingPrice + futurePrice) / 2;
          earnings = averagePrice * volume;
          commission = this.commission(earnings);
          earnings -= commission;
          if (true) {
            account.balance += earnings;
            this.products[symbol].price = futurePrice;
            account.stocks[symbol].volume -= volume;
            this.products[symbol].volume += volume;
            return query.reply();
          } else {
            return query.refuse("for some reason");
          }
        } else {
          return query.refuse("no more stocks on the market to buy, please wait");
        }
      } else {
        return query.refuse("symbol " + symbol + " not found");
      }
    };

    Market.prototype.balance = function(query) {
      var account;
      account = this.validate(query);
      if (!account) {
        return query.refuse('invalid session');
      }
      return query.reply(account.balance);
    };

    Market.prototype.commission = function(order) {
      var category, estimated;
      category = "A";
      switch (category) {
        case "A":
          if (order <= 500000) {
            return 1990;
          } else {
            return order * 0.006;
          }
          break;
        case "B":
          if (order <= 1000000) {
            return 5500;
          } else {
            estimated = order * 0.0048;
            if (estimated < 8950) {
              estimated = 8950;
            }
            return estimated;
          }
          break;
        case "C":
          if (order <= 7750000) {
            return 16650;
          } else {
            return order * 0.0022;
          }
          break;
        case "D":
          if (order <= 10000000) {
            return 9900;
          } else {
            return order * 0.0012;
          }
          break;
        default:
          return 0;
      }
    };

    exports.Market = Market;

    exports.Session = Session;

    exports.Stock = Stock;

    exports.humanize = humanize;

    return Market;

  })();

}).call(this);
